// This code contains NVIDIA Confidential Information and is disclosed to you 
// under a form of NVIDIA software license agreement provided separately to you.
//
// Notice
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and 
// any modifications thereto. Any use, reproduction, disclosure, or 
// distribution of this software and related documentation without an express 
// license agreement from NVIDIA Corporation is strictly prohibited.
// 
// ALL NVIDIA DESIGN SPECIFICATIONS, CODE ARE PROVIDED "AS IS.". NVIDIA MAKES
// NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE.
//
// Information and code furnished is believed to be accurate and reliable.
// However, NVIDIA Corporation assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA Corporation. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA Corporation products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA Corporation.
//
// Copyright (c) 2008-2011 NVIDIA Corporation. All rights reserved.
// Copyright (c) 2004-2008 AGEIA Technologies, Inc. All rights reserved.
// Copyright (c) 2001-2004 NovodeX AG. All rights reserved.

// This code is auto-generated by the PhysX Clang metadata generator.  Do not edit or be
// prepared for your edits to be quietly ignored next time the clang metadata generator is
// run.  You can find the most recent version of clang metadata generator by contacting
// Chris Nuernberger <chrisn@nvidia.com> or Dilip or Adam.
// The source code for the generate was at one time checked into:
// physx/PhysXMetaDataGenerator/llvm/tools/clang/lib/Frontend/PhysXMetaDataAction.cpp
#define THERE_IS_NO_INCLUDE_GUARD_HERE_FOR_A_REASON

#define PX_PROPERTY_INFO_NAME PxExtensionsPropertyInfoName
	static PxU32ToName g_physx__PxJointActorIndex__EnumConversion[] = {
		{ "eACTOR0", static_cast<PxU32>( physx::PxJointActorIndex::eACTOR0 ) },
		{ "eACTOR1", static_cast<PxU32>( physx::PxJointActorIndex::eACTOR1 ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxJointActorIndex::Enum > { PxEnumTraits() : NameConversion( g_physx__PxJointActorIndex__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxJointType__EnumConversion[] = {
		{ "eD6", static_cast<PxU32>( physx::PxJointType::eD6 ) },
		{ "eDISTANCE", static_cast<PxU32>( physx::PxJointType::eDISTANCE ) },
		{ "eFIXED", static_cast<PxU32>( physx::PxJointType::eFIXED ) },
		{ "ePRISMATIC", static_cast<PxU32>( physx::PxJointType::ePRISMATIC ) },
		{ "eREVOLUTE", static_cast<PxU32>( physx::PxJointType::eREVOLUTE ) },
		{ "eSPHERICAL", static_cast<PxU32>( physx::PxJointType::eSPHERICAL ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxJointType::Enum > { PxEnumTraits() : NameConversion( g_physx__PxJointType__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxJoint;
	struct PxJointGeneratedValues
	{
		PxRigidActor * Actors[2];
		PxTransform LocalPose[physx::PxJointActorIndex::COUNT];
		PxReal BreakForce[2];
		PxConstraintFlags ConstraintFlags;
		const char * Name;
		PxScene * Scene;
		PxJointType::Enum Type;
		const char * ClassName;
		void * UserData;
		  PxJointGeneratedValues( const PxJoint* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJoint, Actors, PxJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJoint, LocalPose, PxJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJoint, BreakForce, PxJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJoint, ConstraintFlags, PxJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJoint, Name, PxJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJoint, Scene, PxJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJoint, Type, PxJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJoint, ClassName, PxJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJoint, UserData, PxJointGeneratedValues)
	struct PxJointGeneratedInfo

	{
		static const char* getClassName() { return "PxJoint"; }
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxJoint_Actors, PxJoint, PxRigidActor * > Actors;
		PxIndexedPropertyInfo<PX_PROPERTY_INFO_NAME::PxJoint_LocalPose, PxJoint, PxJointActorIndex::Enum, PxTransform > LocalPose;
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxJoint_BreakForce, PxJoint, PxReal > BreakForce;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxJoint_ConstraintFlags, PxJoint, PxConstraintFlags, PxConstraintFlags > ConstraintFlags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxJoint_Name, PxJoint, const char *, const char * > Name;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxJoint_Scene, PxJoint, PxScene * > Scene;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxJoint_Type, PxJoint, PxJointType::Enum > Type;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxJoint_ClassName, PxJoint, const char * > ClassName;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxJoint_UserData, PxJoint, void *, void * > UserData;

		 PxJointGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxJoint*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 9; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Actors, inStartIndex + 0 );; 
			inOperator( LocalPose, inStartIndex + 1 );; 
			inOperator( BreakForce, inStartIndex + 2 );; 
			inOperator( ConstraintFlags, inStartIndex + 3 );; 
			inOperator( Name, inStartIndex + 4 );; 
			inOperator( Scene, inStartIndex + 5 );; 
			inOperator( Type, inStartIndex + 6 );; 
			inOperator( ClassName, inStartIndex + 7 );; 
			inOperator( UserData, inStartIndex + 8 );; 
			return 9 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxJoint> { PxJointGeneratedInfo Info; };

	static PxU32ToName g_physx__PxDistanceJointFlag__EnumConversion[] = {
		{ "eMAX_DISTANCE_ENABLED", static_cast<PxU32>( physx::PxDistanceJointFlag::eMAX_DISTANCE_ENABLED ) },
		{ "eMIN_DISTANCE_ENABLED", static_cast<PxU32>( physx::PxDistanceJointFlag::eMIN_DISTANCE_ENABLED ) },
		{ "eSPRING_ENABLED", static_cast<PxU32>( physx::PxDistanceJointFlag::eSPRING_ENABLED ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxDistanceJointFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxDistanceJointFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxDistanceJoint;
	struct PxDistanceJointGeneratedValues
		: PxJointGeneratedValues	{
		PxReal MinDistance;
		PxReal MaxDistance;
		PxReal Tolerance;
		PxReal Spring;
		PxReal Damping;
		PxDistanceJointFlags DistanceJointFlags;
		const char * ClassName;
		  PxDistanceJointGeneratedValues( const PxDistanceJoint* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDistanceJoint, MinDistance, PxDistanceJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDistanceJoint, MaxDistance, PxDistanceJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDistanceJoint, Tolerance, PxDistanceJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDistanceJoint, Spring, PxDistanceJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDistanceJoint, Damping, PxDistanceJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDistanceJoint, DistanceJointFlags, PxDistanceJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDistanceJoint, ClassName, PxDistanceJointGeneratedValues)
	struct PxDistanceJointGeneratedInfo
		: PxJointGeneratedInfo
	{
		static const char* getClassName() { return "PxDistanceJoint"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDistanceJoint_MinDistance, PxDistanceJoint, PxReal, PxReal > MinDistance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDistanceJoint_MaxDistance, PxDistanceJoint, PxReal, PxReal > MaxDistance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDistanceJoint_Tolerance, PxDistanceJoint, PxReal, PxReal > Tolerance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDistanceJoint_Spring, PxDistanceJoint, PxReal, PxReal > Spring;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDistanceJoint_Damping, PxDistanceJoint, PxReal, PxReal > Damping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDistanceJoint_DistanceJointFlags, PxDistanceJoint, PxDistanceJointFlags, PxDistanceJointFlags > DistanceJointFlags;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxDistanceJoint_ClassName, PxDistanceJoint, const char * > ClassName;

		 PxDistanceJointGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxDistanceJoint*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxJointGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxJointGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxJointGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 7; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxJointGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( MinDistance, inStartIndex + 0 );; 
			inOperator( MaxDistance, inStartIndex + 1 );; 
			inOperator( Tolerance, inStartIndex + 2 );; 
			inOperator( Spring, inStartIndex + 3 );; 
			inOperator( Damping, inStartIndex + 4 );; 
			inOperator( DistanceJointFlags, inStartIndex + 5 );; 
			inOperator( ClassName, inStartIndex + 6 );; 
			return 7 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxDistanceJoint> { PxDistanceJointGeneratedInfo Info; };

	class PxFixedJoint;
	struct PxFixedJointGeneratedValues
		: PxJointGeneratedValues	{
		PxReal ProjectionLinearTolerance;
		PxReal ProjectionAngularTolerance;
		const char * ClassName;
		  PxFixedJointGeneratedValues( const PxFixedJoint* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxFixedJoint, ProjectionLinearTolerance, PxFixedJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxFixedJoint, ProjectionAngularTolerance, PxFixedJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxFixedJoint, ClassName, PxFixedJointGeneratedValues)
	struct PxFixedJointGeneratedInfo
		: PxJointGeneratedInfo
	{
		static const char* getClassName() { return "PxFixedJoint"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxFixedJoint_ProjectionLinearTolerance, PxFixedJoint, PxReal, PxReal > ProjectionLinearTolerance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxFixedJoint_ProjectionAngularTolerance, PxFixedJoint, PxReal, PxReal > ProjectionAngularTolerance;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxFixedJoint_ClassName, PxFixedJoint, const char * > ClassName;

		 PxFixedJointGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxFixedJoint*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxJointGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxJointGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxJointGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 3; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxJointGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( ProjectionLinearTolerance, inStartIndex + 0 );; 
			inOperator( ProjectionAngularTolerance, inStartIndex + 1 );; 
			inOperator( ClassName, inStartIndex + 2 );; 
			return 3 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxFixedJoint> { PxFixedJointGeneratedInfo Info; };

	class PxJointLimitParameters;
	struct PxJointLimitParametersGeneratedValues
	{
		_Bool IsValid;
		PxReal Restitution;
		PxReal Spring;
		PxReal Damping;
		PxReal ContactDistance;
		  PxJointLimitParametersGeneratedValues( const PxJointLimitParameters* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJointLimitParameters, IsValid, PxJointLimitParametersGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJointLimitParameters, Restitution, PxJointLimitParametersGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJointLimitParameters, Spring, PxJointLimitParametersGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJointLimitParameters, Damping, PxJointLimitParametersGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJointLimitParameters, ContactDistance, PxJointLimitParametersGeneratedValues)
	struct PxJointLimitParametersGeneratedInfo

	{
		static const char* getClassName() { return "PxJointLimitParameters"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxJointLimitParameters_IsValid, PxJointLimitParameters, _Bool > IsValid;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxJointLimitParameters_Restitution, PxJointLimitParameters, PxReal, PxReal > Restitution;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxJointLimitParameters_Spring, PxJointLimitParameters, PxReal, PxReal > Spring;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxJointLimitParameters_Damping, PxJointLimitParameters, PxReal, PxReal > Damping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxJointLimitParameters_ContactDistance, PxJointLimitParameters, PxReal, PxReal > ContactDistance;

		 PxJointLimitParametersGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxJointLimitParameters*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 5; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( IsValid, inStartIndex + 0 );; 
			inOperator( Restitution, inStartIndex + 1 );; 
			inOperator( Spring, inStartIndex + 2 );; 
			inOperator( Damping, inStartIndex + 3 );; 
			inOperator( ContactDistance, inStartIndex + 4 );; 
			return 5 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxJointLimitParameters> { PxJointLimitParametersGeneratedInfo Info; };

	class PxJointLimit;
	struct PxJointLimitGeneratedValues
		: PxJointLimitParametersGeneratedValues	{
		_Bool IsValid;
		PxReal Value;
		  PxJointLimitGeneratedValues( const PxJointLimit* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJointLimit, IsValid, PxJointLimitGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJointLimit, Value, PxJointLimitGeneratedValues)
	struct PxJointLimitGeneratedInfo
		: PxJointLimitParametersGeneratedInfo
	{
		static const char* getClassName() { return "PxJointLimit"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxJointLimit_IsValid, PxJointLimit, _Bool > IsValid;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxJointLimit_Value, PxJointLimit, PxReal, PxReal > Value;

		 PxJointLimitGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxJointLimit*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxJointLimitParametersGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxJointLimitParametersGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxJointLimitParametersGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 2; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxJointLimitParametersGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( IsValid, inStartIndex + 0 );; 
			inOperator( Value, inStartIndex + 1 );; 
			return 2 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxJointLimit> { PxJointLimitGeneratedInfo Info; };

	class PxJointLimitPair;
	struct PxJointLimitPairGeneratedValues
		: PxJointLimitParametersGeneratedValues	{
		_Bool IsValid;
		PxReal Upper;
		PxReal Lower;
		  PxJointLimitPairGeneratedValues( const PxJointLimitPair* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJointLimitPair, IsValid, PxJointLimitPairGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJointLimitPair, Upper, PxJointLimitPairGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJointLimitPair, Lower, PxJointLimitPairGeneratedValues)
	struct PxJointLimitPairGeneratedInfo
		: PxJointLimitParametersGeneratedInfo
	{
		static const char* getClassName() { return "PxJointLimitPair"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxJointLimitPair_IsValid, PxJointLimitPair, _Bool > IsValid;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxJointLimitPair_Upper, PxJointLimitPair, PxReal, PxReal > Upper;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxJointLimitPair_Lower, PxJointLimitPair, PxReal, PxReal > Lower;

		 PxJointLimitPairGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxJointLimitPair*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxJointLimitParametersGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxJointLimitParametersGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxJointLimitParametersGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 3; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxJointLimitParametersGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( IsValid, inStartIndex + 0 );; 
			inOperator( Upper, inStartIndex + 1 );; 
			inOperator( Lower, inStartIndex + 2 );; 
			return 3 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxJointLimitPair> { PxJointLimitPairGeneratedInfo Info; };

	class PxJointLimitCone;
	struct PxJointLimitConeGeneratedValues
		: PxJointLimitParametersGeneratedValues	{
		_Bool IsValid;
		PxReal YAngle;
		PxReal ZAngle;
		  PxJointLimitConeGeneratedValues( const PxJointLimitCone* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJointLimitCone, IsValid, PxJointLimitConeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJointLimitCone, YAngle, PxJointLimitConeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxJointLimitCone, ZAngle, PxJointLimitConeGeneratedValues)
	struct PxJointLimitConeGeneratedInfo
		: PxJointLimitParametersGeneratedInfo
	{
		static const char* getClassName() { return "PxJointLimitCone"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxJointLimitCone_IsValid, PxJointLimitCone, _Bool > IsValid;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxJointLimitCone_YAngle, PxJointLimitCone, PxReal, PxReal > YAngle;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxJointLimitCone_ZAngle, PxJointLimitCone, PxReal, PxReal > ZAngle;

		 PxJointLimitConeGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxJointLimitCone*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxJointLimitParametersGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxJointLimitParametersGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxJointLimitParametersGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 3; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxJointLimitParametersGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( IsValid, inStartIndex + 0 );; 
			inOperator( YAngle, inStartIndex + 1 );; 
			inOperator( ZAngle, inStartIndex + 2 );; 
			return 3 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxJointLimitCone> { PxJointLimitConeGeneratedInfo Info; };

	static PxU32ToName g_physx__PxPrismaticJointFlag__EnumConversion[] = {
		{ "eLIMIT_ENABLED", static_cast<PxU32>( physx::PxPrismaticJointFlag::eLIMIT_ENABLED ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxPrismaticJointFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxPrismaticJointFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxPrismaticJoint;
	struct PxPrismaticJointGeneratedValues
		: PxJointGeneratedValues	{
		PxJointLimitPair Limit;
		PxPrismaticJointFlags PrismaticJointFlags;
		PxReal ProjectionLinearTolerance;
		PxReal ProjectionAngularTolerance;
		const char * ClassName;
		  PxPrismaticJointGeneratedValues( const PxPrismaticJoint* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxPrismaticJoint, Limit, PxPrismaticJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxPrismaticJoint, PrismaticJointFlags, PxPrismaticJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxPrismaticJoint, ProjectionLinearTolerance, PxPrismaticJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxPrismaticJoint, ProjectionAngularTolerance, PxPrismaticJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxPrismaticJoint, ClassName, PxPrismaticJointGeneratedValues)
	struct PxPrismaticJointGeneratedInfo
		: PxJointGeneratedInfo
	{
		static const char* getClassName() { return "PxPrismaticJoint"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxPrismaticJoint_Limit, PxPrismaticJoint, const PxJointLimitPair &, PxJointLimitPair > Limit;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxPrismaticJoint_PrismaticJointFlags, PxPrismaticJoint, PxPrismaticJointFlags, PxPrismaticJointFlags > PrismaticJointFlags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxPrismaticJoint_ProjectionLinearTolerance, PxPrismaticJoint, PxReal, PxReal > ProjectionLinearTolerance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxPrismaticJoint_ProjectionAngularTolerance, PxPrismaticJoint, PxReal, PxReal > ProjectionAngularTolerance;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxPrismaticJoint_ClassName, PxPrismaticJoint, const char * > ClassName;

		 PxPrismaticJointGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxPrismaticJoint*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxJointGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxJointGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxJointGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 5; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxJointGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Limit, inStartIndex + 0 );; 
			inOperator( PrismaticJointFlags, inStartIndex + 1 );; 
			inOperator( ProjectionLinearTolerance, inStartIndex + 2 );; 
			inOperator( ProjectionAngularTolerance, inStartIndex + 3 );; 
			inOperator( ClassName, inStartIndex + 4 );; 
			return 5 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxPrismaticJoint> { PxPrismaticJointGeneratedInfo Info; };

	static PxU32ToName g_physx__PxRevoluteJointFlag__EnumConversion[] = {
		{ "eLIMIT_ENABLED", static_cast<PxU32>( physx::PxRevoluteJointFlag::eLIMIT_ENABLED ) },
		{ "eDRIVE_ENABLED", static_cast<PxU32>( physx::PxRevoluteJointFlag::eDRIVE_ENABLED ) },
		{ "eDRIVE_FREESPIN", static_cast<PxU32>( physx::PxRevoluteJointFlag::eDRIVE_FREESPIN ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxRevoluteJointFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxRevoluteJointFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxRevoluteJoint;
	struct PxRevoluteJointGeneratedValues
		: PxJointGeneratedValues	{
		PxJointLimitPair Limit;
		PxReal DriveVelocity;
		PxReal DriveForceLimit;
		PxReal DriveGearRatio;
		PxRevoluteJointFlags RevoluteJointFlags;
		PxReal ProjectionLinearTolerance;
		PxReal ProjectionAngularTolerance;
		const char * ClassName;
		  PxRevoluteJointGeneratedValues( const PxRevoluteJoint* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRevoluteJoint, Limit, PxRevoluteJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRevoluteJoint, DriveVelocity, PxRevoluteJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRevoluteJoint, DriveForceLimit, PxRevoluteJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRevoluteJoint, DriveGearRatio, PxRevoluteJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRevoluteJoint, RevoluteJointFlags, PxRevoluteJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRevoluteJoint, ProjectionLinearTolerance, PxRevoluteJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRevoluteJoint, ProjectionAngularTolerance, PxRevoluteJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRevoluteJoint, ClassName, PxRevoluteJointGeneratedValues)
	struct PxRevoluteJointGeneratedInfo
		: PxJointGeneratedInfo
	{
		static const char* getClassName() { return "PxRevoluteJoint"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRevoluteJoint_Limit, PxRevoluteJoint, const PxJointLimitPair &, PxJointLimitPair > Limit;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRevoluteJoint_DriveVelocity, PxRevoluteJoint, PxReal, PxReal > DriveVelocity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRevoluteJoint_DriveForceLimit, PxRevoluteJoint, PxReal, PxReal > DriveForceLimit;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRevoluteJoint_DriveGearRatio, PxRevoluteJoint, PxReal, PxReal > DriveGearRatio;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRevoluteJoint_RevoluteJointFlags, PxRevoluteJoint, PxRevoluteJointFlags, PxRevoluteJointFlags > RevoluteJointFlags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRevoluteJoint_ProjectionLinearTolerance, PxRevoluteJoint, PxReal, PxReal > ProjectionLinearTolerance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRevoluteJoint_ProjectionAngularTolerance, PxRevoluteJoint, PxReal, PxReal > ProjectionAngularTolerance;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxRevoluteJoint_ClassName, PxRevoluteJoint, const char * > ClassName;

		 PxRevoluteJointGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxRevoluteJoint*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxJointGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxJointGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxJointGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 8; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxJointGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Limit, inStartIndex + 0 );; 
			inOperator( DriveVelocity, inStartIndex + 1 );; 
			inOperator( DriveForceLimit, inStartIndex + 2 );; 
			inOperator( DriveGearRatio, inStartIndex + 3 );; 
			inOperator( RevoluteJointFlags, inStartIndex + 4 );; 
			inOperator( ProjectionLinearTolerance, inStartIndex + 5 );; 
			inOperator( ProjectionAngularTolerance, inStartIndex + 6 );; 
			inOperator( ClassName, inStartIndex + 7 );; 
			return 8 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxRevoluteJoint> { PxRevoluteJointGeneratedInfo Info; };

	static PxU32ToName g_physx__PxSphericalJointFlag__EnumConversion[] = {
		{ "eLIMIT_ENABLED", static_cast<PxU32>( physx::PxSphericalJointFlag::eLIMIT_ENABLED ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxSphericalJointFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxSphericalJointFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxSphericalJoint;
	struct PxSphericalJointGeneratedValues
		: PxJointGeneratedValues	{
		PxJointLimitCone LimitCone;
		PxSphericalJointFlags SphericalJointFlags;
		PxReal ProjectionLinearTolerance;
		const char * ClassName;
		  PxSphericalJointGeneratedValues( const PxSphericalJoint* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSphericalJoint, LimitCone, PxSphericalJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSphericalJoint, SphericalJointFlags, PxSphericalJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSphericalJoint, ProjectionLinearTolerance, PxSphericalJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSphericalJoint, ClassName, PxSphericalJointGeneratedValues)
	struct PxSphericalJointGeneratedInfo
		: PxJointGeneratedInfo
	{
		static const char* getClassName() { return "PxSphericalJoint"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSphericalJoint_LimitCone, PxSphericalJoint, const PxJointLimitCone &, PxJointLimitCone > LimitCone;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSphericalJoint_SphericalJointFlags, PxSphericalJoint, PxSphericalJointFlags, PxSphericalJointFlags > SphericalJointFlags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSphericalJoint_ProjectionLinearTolerance, PxSphericalJoint, PxReal, PxReal > ProjectionLinearTolerance;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxSphericalJoint_ClassName, PxSphericalJoint, const char * > ClassName;

		 PxSphericalJointGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxSphericalJoint*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxJointGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxJointGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxJointGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 4; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxJointGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( LimitCone, inStartIndex + 0 );; 
			inOperator( SphericalJointFlags, inStartIndex + 1 );; 
			inOperator( ProjectionLinearTolerance, inStartIndex + 2 );; 
			inOperator( ClassName, inStartIndex + 3 );; 
			return 4 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxSphericalJoint> { PxSphericalJointGeneratedInfo Info; };

	static PxU32ToName g_physx__PxD6Axis__EnumConversion[] = {
		{ "eX", static_cast<PxU32>( physx::PxD6Axis::eX ) },
		{ "eY", static_cast<PxU32>( physx::PxD6Axis::eY ) },
		{ "eZ", static_cast<PxU32>( physx::PxD6Axis::eZ ) },
		{ "eTWIST", static_cast<PxU32>( physx::PxD6Axis::eTWIST ) },
		{ "eSWING1", static_cast<PxU32>( physx::PxD6Axis::eSWING1 ) },
		{ "eSWING2", static_cast<PxU32>( physx::PxD6Axis::eSWING2 ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxD6Axis::Enum > { PxEnumTraits() : NameConversion( g_physx__PxD6Axis__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxD6Motion__EnumConversion[] = {
		{ "eLOCKED", static_cast<PxU32>( physx::PxD6Motion::eLOCKED ) },
		{ "eLIMITED", static_cast<PxU32>( physx::PxD6Motion::eLIMITED ) },
		{ "eFREE", static_cast<PxU32>( physx::PxD6Motion::eFREE ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxD6Motion::Enum > { PxEnumTraits() : NameConversion( g_physx__PxD6Motion__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_physx__PxD6Drive__EnumConversion[] = {
		{ "eX", static_cast<PxU32>( physx::PxD6Drive::eX ) },
		{ "eY", static_cast<PxU32>( physx::PxD6Drive::eY ) },
		{ "eZ", static_cast<PxU32>( physx::PxD6Drive::eZ ) },
		{ "eSWING", static_cast<PxU32>( physx::PxD6Drive::eSWING ) },
		{ "eTWIST", static_cast<PxU32>( physx::PxD6Drive::eTWIST ) },
		{ "eSLERP", static_cast<PxU32>( physx::PxD6Drive::eSLERP ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxD6Drive::Enum > { PxEnumTraits() : NameConversion( g_physx__PxD6Drive__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxD6Joint;
	struct PxD6JointGeneratedValues
		: PxJointGeneratedValues	{
		PxD6Motion::Enum Motion[physx::PxD6Axis::eCOUNT];
		PxJointLimit LinearLimit;
		PxJointLimitPair TwistLimit;
		PxJointLimitCone SwingLimit;
		PxD6JointDrive Drive[physx::PxD6Drive::eCOUNT];
		PxTransform DrivePosition;
		PxVec3 DriveVelocity[2];
		PxReal ProjectionLinearTolerance;
		PxReal ProjectionAngularTolerance;
		const char * ClassName;
		  PxD6JointGeneratedValues( const PxD6Joint* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxD6Joint, Motion, PxD6JointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxD6Joint, LinearLimit, PxD6JointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxD6Joint, TwistLimit, PxD6JointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxD6Joint, SwingLimit, PxD6JointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxD6Joint, Drive, PxD6JointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxD6Joint, DrivePosition, PxD6JointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxD6Joint, DriveVelocity, PxD6JointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxD6Joint, ProjectionLinearTolerance, PxD6JointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxD6Joint, ProjectionAngularTolerance, PxD6JointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxD6Joint, ClassName, PxD6JointGeneratedValues)
	struct PxD6JointGeneratedInfo
		: PxJointGeneratedInfo
	{
		static const char* getClassName() { return "PxD6Joint"; }
		PxIndexedPropertyInfo<PX_PROPERTY_INFO_NAME::PxD6Joint_Motion, PxD6Joint, PxD6Axis::Enum, PxD6Motion::Enum > Motion;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxD6Joint_LinearLimit, PxD6Joint, const PxJointLimit &, PxJointLimit > LinearLimit;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxD6Joint_TwistLimit, PxD6Joint, const PxJointLimitPair &, PxJointLimitPair > TwistLimit;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxD6Joint_SwingLimit, PxD6Joint, const PxJointLimitCone &, PxJointLimitCone > SwingLimit;
		PxIndexedPropertyInfo<PX_PROPERTY_INFO_NAME::PxD6Joint_Drive, PxD6Joint, PxD6Drive::Enum, PxD6JointDrive > Drive;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxD6Joint_DrivePosition, PxD6Joint, const PxTransform &, PxTransform > DrivePosition;
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxD6Joint_DriveVelocity, PxD6Joint, PxVec3 > DriveVelocity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxD6Joint_ProjectionLinearTolerance, PxD6Joint, PxReal, PxReal > ProjectionLinearTolerance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxD6Joint_ProjectionAngularTolerance, PxD6Joint, PxReal, PxReal > ProjectionAngularTolerance;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxD6Joint_ClassName, PxD6Joint, const char * > ClassName;

		 PxD6JointGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxD6Joint*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxJointGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxJointGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxJointGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 10; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxJointGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Motion, inStartIndex + 0 );; 
			inOperator( LinearLimit, inStartIndex + 1 );; 
			inOperator( TwistLimit, inStartIndex + 2 );; 
			inOperator( SwingLimit, inStartIndex + 3 );; 
			inOperator( Drive, inStartIndex + 4 );; 
			inOperator( DrivePosition, inStartIndex + 5 );; 
			inOperator( DriveVelocity, inStartIndex + 6 );; 
			inOperator( ProjectionLinearTolerance, inStartIndex + 7 );; 
			inOperator( ProjectionAngularTolerance, inStartIndex + 8 );; 
			inOperator( ClassName, inStartIndex + 9 );; 
			return 10 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxD6Joint> { PxD6JointGeneratedInfo Info; };

	static PxU32ToName g_physx__PxD6JointDriveFlag__EnumConversion[] = {
		{ "eACCELERATION", static_cast<PxU32>( physx::PxD6JointDriveFlag::eACCELERATION ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< physx::PxD6JointDriveFlag::Enum > { PxEnumTraits() : NameConversion( g_physx__PxD6JointDriveFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxD6JointDrive;
	struct PxD6JointDriveGeneratedValues
	{
		_Bool IsValid;
		PxReal Spring;
		PxReal Damping;
		PxReal ForceLimit;
		PxD6JointDriveFlags Flags;
		  PxD6JointDriveGeneratedValues( const PxD6JointDrive* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxD6JointDrive, IsValid, PxD6JointDriveGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxD6JointDrive, Spring, PxD6JointDriveGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxD6JointDrive, Damping, PxD6JointDriveGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxD6JointDrive, ForceLimit, PxD6JointDriveGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxD6JointDrive, Flags, PxD6JointDriveGeneratedValues)
	struct PxD6JointDriveGeneratedInfo

	{
		static const char* getClassName() { return "PxD6JointDrive"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxD6JointDrive_IsValid, PxD6JointDrive, _Bool > IsValid;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxD6JointDrive_Spring, PxD6JointDrive, PxReal, PxReal > Spring;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxD6JointDrive_Damping, PxD6JointDrive, PxReal, PxReal > Damping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxD6JointDrive_ForceLimit, PxD6JointDrive, PxReal, PxReal > ForceLimit;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxD6JointDrive_Flags, PxD6JointDrive, PxD6JointDriveFlags, PxD6JointDriveFlags > Flags;

		 PxD6JointDriveGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxD6JointDrive*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 5; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( IsValid, inStartIndex + 0 );; 
			inOperator( Spring, inStartIndex + 1 );; 
			inOperator( Damping, inStartIndex + 2 );; 
			inOperator( ForceLimit, inStartIndex + 3 );; 
			inOperator( Flags, inStartIndex + 4 );; 
			return 5 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxD6JointDrive> { PxD6JointDriveGeneratedInfo Info; };



#undef THERE_IS_NO_INCLUDE_GUARD_HERE_FOR_A_REASON
#undef PX_PROPERTY_INFO_NAME
