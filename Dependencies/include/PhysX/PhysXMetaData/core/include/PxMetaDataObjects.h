// This code contains NVIDIA Confidential Information and is disclosed to you 
// under a form of NVIDIA software license agreement provided separately to you.
//
// Notice
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and 
// any modifications thereto. Any use, reproduction, disclosure, or 
// distribution of this software and related documentation without an express 
// license agreement from NVIDIA Corporation is strictly prohibited.
// 
// ALL NVIDIA DESIGN SPECIFICATIONS, CODE ARE PROVIDED "AS IS.". NVIDIA MAKES
// NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE.
//
// Information and code furnished is believed to be accurate and reliable.
// However, NVIDIA Corporation assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA Corporation. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA Corporation products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA Corporation.
//
// Copyright (c) 2008-2011 NVIDIA Corporation. All rights reserved.
// Copyright (c) 2004-2008 AGEIA Technologies, Inc. All rights reserved.
// Copyright (c) 2001-2004 NovodeX AG. All rights reserved.

#ifndef PX_METADATAOBJECTS_H
#define PX_METADATAOBJECTS_H
#include "PxPhysicsAPI.h"
#include "PxClothTypes.h"
#include "PxClothFabric.h"
#include "PxCloth.h"
#include "PxClothCollisionData.h"
#include "PxClothReadData.h"

/** \addtogroup physics
@{
*/

namespace physx
{

class PxArticulationLink;
class PxArticulationJoint;

struct PxPropertyInfoName
{
	enum Enum
	{
		Unnamed = 0,
#include "PxAutoGeneratedMetaDataObjectNames.h"
		LastPxPropertyInfoName,
	};
};

struct PxU32ToName
{
	const char* mName;
	PxU32		mValue;
};

struct PxPropertyInfoBase
{
	const char* mName;
	PxU32 mKey; 
	PxPropertyInfoBase( const char* n, PxU32 inKey )
		: mName( n )
		, mKey( inKey )
	{
	}
};

template<PxU32 TKey>
struct PxPropertyInfoParameterizedBase : public PxPropertyInfoBase
{
	PxPropertyInfoParameterizedBase( const char* inName )
		: PxPropertyInfoBase( inName, TKey ) {}
};

template<PxU32 TKey, typename TObjType, typename TPropertyType>
struct PxReadOnlyPropertyInfo : public PxPropertyInfoParameterizedBase<TKey>
{
	typedef TPropertyType (*TGetterType)( const TObjType* );
	TGetterType mGetter;
	PxReadOnlyPropertyInfo( const char* inName, TGetterType inGetter )
		: PxPropertyInfoParameterizedBase<TKey>( inName )
		, mGetter( inGetter ) {}
	TPropertyType get( const TObjType* inObj ) const { return mGetter( inObj ); }
};

template<PxU32 TKey, typename TObjType, typename TPropertyType>
struct PxWriteOnlyPropertyInfo : public PxPropertyInfoParameterizedBase<TKey>
{
	typedef void(*TSetterType)( TObjType*, TPropertyType inArg );
	TSetterType mSetter;
	PxWriteOnlyPropertyInfo( const char* inName, TSetterType inSetter )
		: PxPropertyInfoParameterizedBase<TKey>( inName )
		, mSetter( inSetter ) {}
	void set( TObjType* inObj, TPropertyType inArg ) const { mSetter( inObj, inArg ); }
};


//Define the property types on the auto-generated objects.
template<PxU32 TKey, typename TObjType, typename TSetPropType, typename TGetPropType>
struct PxPropertyInfo : public PxReadOnlyPropertyInfo<TKey, TObjType, TGetPropType>
{
	typedef typename PxReadOnlyPropertyInfo<TKey, TObjType, TGetPropType>::TGetterType TGetterType;
	typedef void(*TSetterType)( TObjType*, TSetPropType inArg );
	TSetterType mSetter;

	PxPropertyInfo( const char* inName, TSetterType inSetter, TGetterType inGetter )
		: PxReadOnlyPropertyInfo<TKey, TObjType, TGetPropType>( inName, inGetter )
		, mSetter( inSetter ) {}
	void set( TObjType* inObj, TSetPropType inArg ) const { mSetter( inObj, inArg ); }
};

template<PxU32 TKey, typename TObjType, typename TPropertyType>
struct PxRangePropertyInfo : public PxPropertyInfoParameterizedBase<TKey>
{
	typedef void (*TSetterType)( TObjType*,TPropertyType,TPropertyType);
	typedef void (*TGetterType)( const TObjType*,TPropertyType&,TPropertyType&);

	const char* mArg0Name;
	const char* mArg1Name;

	TSetterType mSetter;
	TGetterType mGetter;

	PxRangePropertyInfo( const char* name, const char* arg0Name, const char* arg1Name
							, TSetterType setter, TGetterType getter )
		: PxPropertyInfoParameterizedBase<TKey>( name )
		, mArg0Name( arg0Name )
		, mArg1Name( arg1Name )
		, mSetter( setter )
		, mGetter( getter )
	{
	}
	void set( TObjType* inObj, TPropertyType arg0, TPropertyType arg1 ) const { mSetter( inObj, arg0, arg1 ); }
	void get( const TObjType* inObj, TPropertyType& arg0, TPropertyType& arg1 ) const { mGetter( inObj, arg0, arg1 ); }
};

template<PxU32 TKey, typename TObjType, typename TIndexType, typename TPropertyType>
struct PxIndexedPropertyInfo : public PxPropertyInfoParameterizedBase<TKey>
{
	typedef void (*TSetterType)( TObjType*, TIndexType, TPropertyType );
	typedef TPropertyType (*TGetterType)( const TObjType* inObj, TIndexType );

	TSetterType mSetter;
	TGetterType mGetter;

	PxIndexedPropertyInfo( const char* name, TSetterType setter, TGetterType getter )
		: PxPropertyInfoParameterizedBase<TKey>( name )
		, mSetter( setter )
		, mGetter( getter )
	{
	}
	void set( TObjType* inObj, TIndexType inIndex, TPropertyType arg ) const { mSetter( inObj, inIndex, arg ); }
	TPropertyType get( const TObjType* inObj, TIndexType inIndex ) const { return mGetter( inObj, inIndex ); }
};

template<PxU32 TKey, typename TObjType, typename TIndex1Type, typename TIndex2Type, typename TPropertyType>
struct PxDualIndexedPropertyInfo : public PxPropertyInfoParameterizedBase<TKey>
{
	typedef void (*TSetterType)( TObjType*, TIndex1Type, TIndex2Type, TPropertyType );
	typedef TPropertyType (*TGetterType)( const TObjType* inObj, TIndex1Type, TIndex2Type );

	TSetterType mSetter;
	TGetterType mGetter;

	PxDualIndexedPropertyInfo( const char* name, TSetterType setter, TGetterType getter )
		: PxPropertyInfoParameterizedBase<TKey>( name )
		, mSetter( setter )
		, mGetter( getter )
	{
	}
	void set( TObjType* inObj, TIndex1Type inIdx1, TIndex2Type inIdx2, TPropertyType arg ) const { mSetter( inObj, inIdx1, inIdx2, arg ); }
	TPropertyType get( const TObjType* inObj, TIndex1Type inIdx1, TIndex2Type inIdx2 ) const { return mGetter( inObj, inIdx1, inIdx2 ); }
};


template<PxU32 TKey, typename TObjType, typename TCollectionType>
struct PxReadOnlyCollectionPropertyInfo : public PxPropertyInfoParameterizedBase<TKey>
{
	typedef PxU32 (*TNbObjectsMember)( const TObjType* );
	typedef PxU32 (*TGetObjectsMember)( const TObjType*, TCollectionType*, PxU32 );

	TGetObjectsMember	mGetObjectsMember;
	TNbObjectsMember	mNbObjectsMember;

	PxReadOnlyCollectionPropertyInfo( const char* inName, TGetObjectsMember inGetter, TNbObjectsMember inNb )
		: PxPropertyInfoParameterizedBase<TKey>( inName )
		, mGetObjectsMember( inGetter )
		, mNbObjectsMember( inNb )
	{
	}
	PxU32 size( const TObjType* inObj ) const { return mNbObjectsMember( inObj ); }
	PxU32 get( const TObjType* inObj, TCollectionType* inBuffer, PxU32 inBufSize ) const { return mGetObjectsMember( inObj, inBuffer, inBufSize); }
};


template<PxU32 TKey, typename TObjType, typename TCollectionType, typename TFilterType>
struct PxReadOnlyFilteredCollectionPropertyInfo : public PxPropertyInfoParameterizedBase<TKey>
{
	typedef PxU32 (*TNbObjectsMember)( const TObjType*, TFilterType );
	typedef PxU32 (*TGetObjectsMember)( const TObjType*, TFilterType, TCollectionType*, PxU32 );

	TGetObjectsMember	mGetObjectsMember;
	TNbObjectsMember	mNbObjectsMember;

	PxReadOnlyFilteredCollectionPropertyInfo( const char* inName, TGetObjectsMember inGetter, TNbObjectsMember inNb )
		: PxPropertyInfoParameterizedBase<TKey>( inName )
		, mGetObjectsMember( inGetter )
		, mNbObjectsMember( inNb )
	{
	}

	PxU32 size( const TObjType* inObj, TFilterType inFilter ) const { return mNbObjectsMember( inObj, inFilter ); }
	PxU32 get( const TObjType* inObj, TFilterType inFilter, TCollectionType* inBuffer, PxU32 inBufSize ) const { return mGetObjectsMember( inObj, inFilter, inBuffer, inBufSize); }
};

template<PxU32 TKey, typename TObjType, typename TCollectionType, typename TCreateArg>
struct PxFactoryCollectionPropertyInfo : public PxReadOnlyCollectionPropertyInfo< TKey, TObjType, TCollectionType >
{
	typedef typename PxReadOnlyCollectionPropertyInfo< TKey, TObjType, TCollectionType >::TGetObjectsMember TGetObjectsMember;
	typedef typename PxReadOnlyCollectionPropertyInfo< TKey, TObjType, TCollectionType >::TNbObjectsMember TNbObjectsMember;
	typedef TCollectionType (*TCreateMember)( TObjType*, TCreateArg );

	TCreateMember mCreateMember;
	PxFactoryCollectionPropertyInfo( const char* inName, TGetObjectsMember inGetter, TNbObjectsMember inNb, TCreateMember inMember )
		: PxReadOnlyCollectionPropertyInfo< TKey, TObjType, TCollectionType >( inName, inGetter, inNb )
		, mCreateMember( inMember )
	{
	}
	TCollectionType create( TObjType* inObj, TCreateArg inArg ) const { return mCreateMember( inObj, inArg ); }
};


template<PxU32 TKey, typename TObjType, typename TCollectionType>
struct PxCollectionPropertyInfo : public PxReadOnlyCollectionPropertyInfo< TKey, TObjType, TCollectionType >
{
	typedef typename PxReadOnlyCollectionPropertyInfo< TKey, TObjType, TCollectionType >::TGetObjectsMember TGetObjectsMember;
	typedef typename PxReadOnlyCollectionPropertyInfo< TKey, TObjType, TCollectionType >::TNbObjectsMember TNbObjectsMember;
	typedef void (*TAddMember)(TObjType*, TCollectionType&);
	typedef void (*TRemoveMember)(TObjType*, TCollectionType&);

	TAddMember		mAddMember;
	TRemoveMember	mRemoveMember;

	PxCollectionPropertyInfo( const char* inName, TGetObjectsMember inGetter, TNbObjectsMember inNb, TAddMember inMember, TRemoveMember inRemoveMember )
		: PxReadOnlyCollectionPropertyInfo< TKey, TObjType, TCollectionType >( inName, inGetter, inNb )
		, mAddMember( inMember )
		, mRemoveMember( inRemoveMember )
	{
	}
	void add( TObjType* inObj, TCollectionType& inArg ) const { mAddMember(inObj, inArg ); }
	void remove( TObjType* inObj, TCollectionType& inArg ) const { mRemoveMember( inObj, inArg ); }
};

template<PxU32 TKey, typename TObjType, typename TCollectionType, typename TFilterType>
struct PxFilteredCollectionPropertyInfo : public PxReadOnlyFilteredCollectionPropertyInfo<TKey, TObjType, TCollectionType, TFilterType>
{
	typedef typename PxReadOnlyFilteredCollectionPropertyInfo< TKey, TObjType, TCollectionType, TFilterType >::TGetObjectsMember TGetObjectsMember;
	typedef typename PxReadOnlyFilteredCollectionPropertyInfo< TKey, TObjType, TCollectionType, TFilterType >::TNbObjectsMember TNbObjectsMember;
	typedef void (*TAddMember)(TObjType*, TCollectionType&);
	typedef void (*TRemoveMember)(TObjType*, TCollectionType&);

	TAddMember		mAddMember;
	TRemoveMember	mRemoveMember;

	PxFilteredCollectionPropertyInfo( const char* inName, TGetObjectsMember inGetter, TNbObjectsMember inNb, TAddMember inMember, TRemoveMember inRemoveMember )
		: PxReadOnlyFilteredCollectionPropertyInfo<TKey, TObjType, TCollectionType, TFilterType>( inName, inGetter, inNb )
		, mAddMember( inMember )
		, mRemoveMember( inRemoveMember )
	{
	}
	void add( TObjType* inObj, TCollectionType& inArg ) const { mAddMember(inObj, inArg ); }
	void remove( TObjType* inObj, TCollectionType& inArg ) const { mRemoveMember( inObj, inArg ); }
};

//create a default info class for when we can't match
//the type correctly.
struct PxUnknownClassInfo
{
	static const char* getClassName() { return "__unknown_class"; }
	template<typename TReturnType, typename TOperator>
	TReturnType visitType( TOperator )
	{
		return TReturnType();
	}
	template<typename TOperator>
	void visitBases( TOperator )
	{
	}
	template<typename TOperator>
	PxU32 visitBaseProperties( TOperator, PxU32 inStartIndex = 0 )
	{
		return inStartIndex;
	}
	template<typename TOperator>
	PxU32 visitInstanceProperties( TOperator, PxU32 inStartIndex = 0 )
	{
		return inStartIndex;
	}
};

template<typename TDataType>
struct PxClassInfoTraits
{
	PxUnknownClassInfo Info;
};

//move the bool typedef to the global namespace.
typedef bool _Bool;


template<PxU32 TPropertyName>
struct PxPropertyToValueStructMemberMap
{
	bool Offset;
};


#define DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( type, prop, valueStruct )																	\
	template<> struct PxPropertyToValueStructMemberMap< PxPropertyInfoName::type##_##prop >												\
	{																																	\
		PxU32 Offset;																													\
		PxPropertyToValueStructMemberMap< PxPropertyInfoName::type##_##prop >() : Offset( offsetof( valueStruct, prop ) ) {}			\
		template<typename TOperator> void visitProp( TOperator inOperator, valueStruct& inStruct ) { inOperator( inStruct.prop );	}	\
	};
	


struct PxShapeGeometryPropertyHelper
{
	PX_PHYSX_CORE_API PxGeometryType::Enum getGeometryType(const PxShape* inShape) const;
	PX_PHYSX_CORE_API bool getGeometry(const PxShape* inShape, PxBoxGeometry& geometry) const;
	PX_PHYSX_CORE_API bool getGeometry(const PxShape* inShape, PxSphereGeometry& geometry) const;
	PX_PHYSX_CORE_API bool getGeometry(const PxShape* inShape, PxCapsuleGeometry& geometry) const;
	PX_PHYSX_CORE_API bool getGeometry(const PxShape* inShape, PxPlaneGeometry& geometry) const;
	PX_PHYSX_CORE_API bool getGeometry(const PxShape* inShape, PxConvexMeshGeometry& geometry) const;
	PX_PHYSX_CORE_API bool getGeometry(const PxShape* inShape, PxTriangleMeshGeometry& geometry) const;
	PX_PHYSX_CORE_API bool getGeometry(const PxShape* inShape, PxHeightFieldGeometry& geometry) const;
};


struct PxShapeGeometryProperty : public PxWriteOnlyPropertyInfo< PxPropertyInfoName::PxShape_Geometry, PxShape, const PxGeometry & >
								, public PxShapeGeometryPropertyHelper
{
	typedef PxWriteOnlyPropertyInfo< PxPropertyInfoName::PxShape_Geometry, PxShape, const PxGeometry & >::TSetterType TSetterType;
	PxShapeGeometryProperty( const char* inName, TSetterType inSetter )
		: PxWriteOnlyPropertyInfo< PxPropertyInfoName::PxShape_Geometry, PxShape, const PxGeometry & >( inName, inSetter )
	{
	}
};

struct PxShapeMaterialsPropertyHelper
{
	PX_PHYSX_CORE_API void setMaterials(PxShape* inShape, PxMaterial*const* materials, PxU32 materialCount) const;
};

struct PxShapeMaterialsProperty : public PxReadOnlyCollectionPropertyInfo<PxPropertyInfoName::PxShape_Materials, PxShape, PxMaterial*>
								, public PxShapeMaterialsPropertyHelper
{
	typedef PxReadOnlyCollectionPropertyInfo< PxPropertyInfoName::PxShape_Materials, PxShape, PxMaterial* >::TGetObjectsMember TGetObjectsMember;
	typedef PxReadOnlyCollectionPropertyInfo< PxPropertyInfoName::PxShape_Materials, PxShape, PxMaterial* >::TNbObjectsMember TNbObjectsMember;
	PxShapeMaterialsProperty( const char* inName, TGetObjectsMember inGetter, TNbObjectsMember inNb )
		: PxReadOnlyCollectionPropertyInfo<PxPropertyInfoName::PxShape_Materials, PxShape, PxMaterial*>( inName, inGetter, inNb )
	{
	}
};

struct PxRigidActorShapeCollectionHelper
{
	PX_PHYSX_CORE_API PxShape* createShape(PxRigidActor* inActor, const PxGeometry& geometry, PxMaterial& material, const PxTransform& localPose = PxTransform::createIdentity()) const;
	PX_PHYSX_CORE_API PxShape* createShape(PxRigidActor* inActor, const PxGeometry& geometry, PxMaterial *const* materials, PxU32 materialCount, const PxTransform& relativePose = PxTransform::createIdentity()) const;
};

struct PxRigidActorShapeCollection : public PxReadOnlyCollectionPropertyInfo<PxPropertyInfoName::PxRigidActor_Shapes, PxRigidActor, PxShape*>
									, public PxRigidActorShapeCollectionHelper
{
	typedef PxReadOnlyCollectionPropertyInfo< PxPropertyInfoName::PxRigidActor_Shapes, PxRigidActor, PxShape* >::TGetObjectsMember TGetObjectsMember;
	typedef PxReadOnlyCollectionPropertyInfo< PxPropertyInfoName::PxRigidActor_Shapes, PxRigidActor, PxShape* >::TNbObjectsMember TNbObjectsMember;
	PxRigidActorShapeCollection( const char* inName, TGetObjectsMember inGetter, TNbObjectsMember inNb )
		: PxReadOnlyCollectionPropertyInfo<PxPropertyInfoName::PxRigidActor_Shapes, PxRigidActor, PxShape*>( inName, inGetter, inNb )
	{
	}
};

struct PxArticulationLinkCollectionPropHelper
{
	PX_PHYSX_CORE_API PxArticulationLink*	createLink(PxArticulation* inArticulation, PxArticulationLink* parent, const PxTransform& pose) const;
};

struct PxArticulationLinkCollectionProp : public PxReadOnlyCollectionPropertyInfo<PxPropertyInfoName::PxArticulation_Links, PxArticulation, PxArticulationLink*>
										, public PxArticulationLinkCollectionPropHelper
{
	PxArticulationLinkCollectionProp( const char* inName, TGetObjectsMember inGetter, TNbObjectsMember inNb )
		: PxReadOnlyCollectionPropertyInfo<PxPropertyInfoName::PxArticulation_Links, PxArticulation, PxArticulationLink*>( inName, inGetter, inNb )
	{
	}
};

template<typename TDataType>
struct PxEnumTraits { PxEnumTraits() : NameConversion( false ) {} bool NameConversion; };

struct RestlengthsProperty : public PxReadOnlyCollectionPropertyInfo<PxPropertyInfoName::PxClothFabric_Restlengths, PxClothFabric, PxReal>
{
	PX_PHYSX_CORE_API RestlengthsProperty();
};

struct PhaseTypesProperty : public PxReadOnlyCollectionPropertyInfo<PxPropertyInfoName::PxClothFabric_PhaseTypes, PxClothFabric, PxClothFabricPhaseType::Enum>
{
	PX_PHYSX_CORE_API PhaseTypesProperty();
};

struct PhaseSolverConfigProperty : public PxReadOnlyCollectionPropertyInfo<PxPropertyInfoName::PxCloth_PhaseSolverConfig, PxCloth, PxClothPhaseSolverConfig>
{
	PX_PHYSX_CORE_API PhaseSolverConfigProperty();
	PX_PHYSX_CORE_API void set( PxCloth* cloth, const PxClothPhaseSolverConfig* data, PxU32 len );
};

struct NumBroadPhaseAddsProperty : public PxIndexedPropertyInfo<PxPropertyInfoName::PxSimulationStatistics_NumBroadPhaseAdds, PxSimulationStatistics, PxSimulationStatistics::VolumeType, PxU32>
{
	PX_PHYSX_CORE_API NumBroadPhaseAddsProperty();
};

struct NumBroadPhaseRemovesProperty : public PxIndexedPropertyInfo<PxPropertyInfoName::PxSimulationStatistics_NumBroadPhaseRemoves, PxSimulationStatistics, PxSimulationStatistics::VolumeType, PxU32>
{
	PX_PHYSX_CORE_API NumBroadPhaseRemovesProperty();
};

struct NumShapesProperty : public PxIndexedPropertyInfo<PxPropertyInfoName::PxSimulationStatistics_NumShapes, PxSimulationStatistics, PxGeometryType::Enum, PxU32>
{
	PX_PHYSX_CORE_API NumShapesProperty();
};


struct NumDiscreteContactPairsProperty : public PxDualIndexedPropertyInfo<PxPropertyInfoName::PxSimulationStatistics_NumDiscreteContactPairs
																			, PxSimulationStatistics
																			, PxGeometryType::Enum
																			, PxGeometryType::Enum
																			, PxU32> 
{
	PX_PHYSX_CORE_API NumDiscreteContactPairsProperty();
};
struct NumModifiedContactPairsProperty : public PxDualIndexedPropertyInfo<PxPropertyInfoName::PxSimulationStatistics_NumModifiedContactPairs
																			, PxSimulationStatistics
																			, PxGeometryType::Enum
																			, PxGeometryType::Enum
																			, PxU32> 
{
	PX_PHYSX_CORE_API NumModifiedContactPairsProperty();
};

struct NumSweptContactPairsProperty : public PxDualIndexedPropertyInfo<PxPropertyInfoName::PxSimulationStatistics_NumSweptContactPairs
																			, PxSimulationStatistics
																			, PxGeometryType::Enum
																			, PxGeometryType::Enum
																			, PxU32> 
{
	PX_PHYSX_CORE_API NumSweptContactPairsProperty();
};
struct NumSweptIntegrationPairsProperty : public PxDualIndexedPropertyInfo<PxPropertyInfoName::PxSimulationStatistics_NumSweptIntegrationPairs
																			, PxSimulationStatistics
																			, PxGeometryType::Enum
																			, PxGeometryType::Enum
																			, PxU32>
{
	PX_PHYSX_CORE_API NumSweptIntegrationPairsProperty();
};

struct NumTriggerPairsProperty : public PxDualIndexedPropertyInfo<PxPropertyInfoName::PxSimulationStatistics_NumTriggerPairs
																			, PxSimulationStatistics
																			, PxGeometryType::Enum
																			, PxGeometryType::Enum
																			, PxU32> 
{
	PX_PHYSX_CORE_API NumTriggerPairsProperty();
};

struct SimulationStatisticsProperty : public PxReadOnlyPropertyInfo<PxPropertyInfoName::PxScene_SimulationStatistics, PxScene, PxSimulationStatistics>
{
	PX_PHYSX_CORE_API SimulationStatisticsProperty();
};

struct PxMetaDataPlane
{
	PxVec3 normal;
	PxReal distance;
	PxMetaDataPlane( PxVec3 n = PxVec3( 0, 0, 0 ), PxReal d = 0 )
		: normal( n )
		, distance( d )
	{
	}
};

struct ProjectionPlaneProperty : public PxPropertyInfo< PxPropertyInfoName::PxParticleBase_ProjectionPlane, PxParticleBase, PxMetaDataPlane, PxMetaDataPlane >
{
	PX_PHYSX_CORE_API ProjectionPlaneProperty();
};

#include "PxAutoGeneratedMetaDataObjects.h"

#undef DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP

	static PxU32ToName g_PxParticleFlags__Conversion[] = {
			{ "eVALID", static_cast<PxU32>( PxParticleFlag::eVALID ) },
			{ "eCOLLISION_WITH_STATIC", static_cast<PxU32>(PxParticleFlag::eCOLLISION_WITH_STATIC) },
			{ "eCOLLISION_WITH_DYNAMIC", static_cast<PxU32>(PxParticleFlag::eCOLLISION_WITH_DYNAMIC) },
			{ "eCOLLISION_WITH_DRAIN", static_cast<PxU32>(PxParticleFlag::eCOLLISION_WITH_DRAIN) },
			{ "eSPATIAL_DATA_STRUCTURE_OVERFLOW", static_cast<PxU32>(PxParticleFlag::eSPATIAL_DATA_STRUCTURE_OVERFLOW) },
	};

	template<> struct PxEnumTraits< PxParticleFlag::Enum > { PxEnumTraits() : NameConversion( g_PxParticleFlags__Conversion ) {} const PxU32ToName* NameConversion; }; 


template<typename TObjType, typename TOperator>
inline PxU32 visitAllProperties( TOperator inOperator )
{
	PxU32 thePropCount = PxClassInfoTraits<TObjType>().Info.visitBaseProperties( inOperator );
	return PxClassInfoTraits<TObjType>().Info.visitInstanceProperties( inOperator, thePropCount );
}

template<typename TObjType, typename TOperator>
inline void visitInstanceProperties( TOperator inOperator )
{
	PxClassInfoTraits<TObjType>().Info.visitInstanceProperties( inOperator, 0 );
}

}

/** @} */
#endif
